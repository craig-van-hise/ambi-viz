# Product Requirements Prompt (PRP): OBR WASM Integration

## 1. Project Context & Objectives

The custom Google Open Binaural Renderer WebAssembly binary (`obr.wasm`) and its Emscripten glue code (`obr.js`) have been successfully compiled and placed in the `/public` directory. Your objective is to finalize the `AudioWorkletProcessor` to instantiate this module, manage the WebAssembly memory heap, and process the Ambisonic audio stream in real-time, completely replacing any legacy `JSAmbisonics` logic.

## 2. Technical Decisions & Memory Architecture

* **Module Loading:** The `obr.js` file is an ES6 module. The Worklet will import it and await its instantiation.
* **Memory Handoff (The `HEAPF32` View):** Web Audio processes arrays in 128-frame chunks. You will use the exported `_malloc` to allocate input and output buffers on the WASM heap *once* during initialization.
* **Signal Chain:** `Source` -> `RawCoefAnalyser` (for visualizer) -> `OBRWorkletNode` -> `Destination`.

## 3. Implementation Phases

### Phase 1: The Worklet Processor Implementation

* **Objective:** Write the C++ memory bridging logic inside the Audio Thread.
* **Instructions:**
1. Create or overwrite `public/worklets/obr-processor.js`.
2. At the top of the file, import the WASM glue code: `import ModuleFactory from '../obr.js';`.
3. In the `OBRProcessor` constructor, initialize a state flag (`this.ready = false`) and start the WASM loading asynchronously:
```javascript
ModuleFactory().then((wasmModule) => {
    this.wasm = wasmModule;
    // Calculate sizes based on processorOptions.order (N channels)
    // Allocate memory: this.inPtr = this.wasm._malloc(...);
    // Initialize: this.wasm._obr_init(order, sampleRate);
    this.ready = true;
});

```


4. In the `process(inputs, outputs)` method:
* If `!this.ready`, return `true` (pass-through silence).
* Copy the 128 frames from `inputs[0]` (N channels) into the WASM heap at `this.inPtr` using `this.wasm.HEAPF32.set(...)`.
* Execute: `this.wasm._obr_process(this.inPtr, this.outPtr, 128);`.
* Copy the stereo results from `this.outPtr` back to `outputs[0][0]` (Left) and `outputs[0][1]` (Right).




* **TDD Checkpoint:** AGENT INSTRUCTION: Verify the syntax of `obr-processor.js`. Do not proceed until you have ensured no dynamic memory allocation (`malloc`/`new`) occurs inside the `process` loop itself.

### Phase 2: AudioEngine Routing

* **Objective:** Connect the React frontend audio graph to the new Worklet.
* **Instructions:**
1. In `src/audio/AudioEngine.ts` (or `OBRDecoder.ts` if you abstracted it), ensure `audioCtx.audioWorklet.addModule('/worklets/obr-processor.js')` is awaited.
2. Instantiate the node: `const obrNode = new AudioWorkletNode(audioCtx, 'obr-processor', { processorOptions: { order: this.order, sampleRate: audioCtx.sampleRate }, outputChannelCount: [2] });`.
3. Connect the graph: `this.rawAnalyser.out.connect(obrNode);` and `obrNode.connect(audioCtx.destination);`.


* **TDD Checkpoint:** AGENT INSTRUCTION: Start the Vite dev server. Drop an Ambisonic `.wav` file into the UI. Verify the browser console does not throw WASM instantiation errors or `out of bounds` memory exceptions.

## 4. Final Review

1. Ensure the `RawCoefAnalyser` is still correctly feeding the WebGL Spherical Harmonics visualizer.
2. Listen to the output. The Ambisonic field should now be successfully decoded to binaural stereo using your custom WASM build.

