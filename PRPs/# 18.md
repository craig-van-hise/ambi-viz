# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are tasked with building a robust, bidirectional Camera Control Panel for the AmbiViz application and resolving a state-loss regression during view mode toggling. 

The architecture strictly delineates how the two view modes operate:
* **Inside Camera:** Manipulated via Yaw, Pitch, and Roll (YPR).
* **Outside Camera:** Manipulated strictly via absolute X, Y, Z spatial coordinates. Its focal target MUST be immutably locked to the origin `(0, 0, 0)`. Panning must be completely disabled to prevent the user from drifting off-target. 
Both cameras must persist their coordinates/rotations when the user toggles between them.

## 2. Technical Decisions & Dependencies
* **Target Locking & Pan Prevention:** `OrbitControls.enablePan` must be set to `false`. The target must be hardcoded to `new THREE.Vector3(0, 0, 0)`.
* **Euler Mapping:** For the Inside view, map Yaw to `rotation.y`, Pitch to `rotation.x`, and Roll to `rotation.z`.
* **State Sync & Performance:** You MUST use the existing `Throttle` utility (`src/utils/Throttle.ts`) to debounce the synchronization between the WebGL render loop/OrbitControls and the React UI. Direct, unthrottled bindings will cause React maximum update depth crashes.

## 3. Implementation Phases

### Phase 1: OrbitControls Hardening & State Persistence
* **Objective:** Prevent camera drift by disabling pan, lock the target to the origin, and cache the camera position between view toggles.
* **Instructions:**
    1.  Locate the Three.js camera and `OrbitControls` initialization (likely `src/visualizer/AmbiScene.ts` or the wrapper component).
    2.  Set `controls.enablePan = false;` to permanently disable right-click/Command-drag panning.
    3.  Create a module-level cache or a `useRef` to store the outside camera's position: `outsidePositionCache = new THREE.Vector3(0, 0, 5)`. (Adjust the default Z value to match your current default zoom).
    4.  Update the View Mode toggle logic:
        * **When switching to Inside:** Read and save the current `camera.position` to `outsidePositionCache`.
        * **When switching to Outside:** Apply `outsidePositionCache` to `camera.position`. Explicitly enforce `controls.target.set(0, 0, 0)`. Call `controls.update()` and `camera.updateProjectionMatrix()`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write or update a test asserting that `controls.enablePan` is false. Assert that toggling to Inside and back to Outside strictly restores `camera.position` from the cache and that `controls.target` equals `(0,0,0)`. Do not proceed until tests PASS.

### Phase 2: Bidirectional Sync Infrastructure
* **Objective:** Create a performant data bridge between the Three.js camera and the React UI.
* **Instructions:**
    1.  Create a React state object: `cameraUIState = { yaw: 0, pitch: 0, roll: 0, x: 0, y: 0, z: 5 }`.
    2.  Bind a listener to `controls.addEventListener('change', ...)` or within the render loop.
    3.  Inside the listener, use `src/utils/Throttle.ts` (e.g., 50ms interval) to read the camera's current state (`camera.rotation` and `camera.position`) and update `cameraUIState`.
    4.  Create an inverse handler: `handleSliderChange(axis, value)`. 
        * If Y, P, or R: Apply to `camera.rotation` (remembering Euler order `YXZ` or similar if required).
        * If X, Y, or Z: Apply to `camera.position.x/y/z`. Ensure `controls.update()` is called immediately after to force the camera to pivot and look at `(0,0,0)`.

### Phase 3: Camera Control Panel UI
* **Objective:** Render the correct sliders dynamically based on the active view mode.
* **Instructions:**
    1.  Create `src/components/CameraControlPanel.tsx`.
    2.  Implement range sliders (`<input type="range">`).
    3.  Implement conditional rendering based on the `viewMode` prop:
        * **If `viewMode === 'inside'`:** Render sliders for Yaw, Pitch, and Roll. (Set bounds mapping to $-\pi$ to $\pi$ radians, or $-180$ to $180$ degrees for the UI).
        * **If `viewMode === 'outside'`:** Render sliders for X, Y, and Z. (Set logical physical bounds, e.g., -20 to 20).
    4.  Bind the values to `cameraUIState` and the `onChange` events to `handleSliderChange`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Validate the UI component. Ensure the X, Y, Z sliders are completely unmounted/hidden when `viewMode === 'inside'` and vice versa for YPR. 

## 4. Final Review
1.  Verify that Command/Right-click dragging on the canvas no longer translates the camera off-center.
2.  Move the Outside camera to a custom X/Y/Z position using the sliders. Toggle to the Inside view, then back to the Outside view. Verify the camera is in the exact custom X/Y/Z position you left it.
3.  Ensure dragging the 3D canvas updates the slider UI smoothly without lagging or crashing React.