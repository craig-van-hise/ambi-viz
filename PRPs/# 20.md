# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are debugging a critical WebGL rendering crash ("Black Screen") triggered by the Inside View YPR sliders in the AmbiViz application. This crash is caused by matrix corruption within the Three.js camera/OrbitControls pipeline.

The objective is to implement strict type coercion (converting React slider strings to floats) and mathematically clamp the pitch to prevent Gimbal Lock singularities.

## 2. Technical Decisions & Dependencies
* **Strict Number Coercion:** Slider `event.target.value` strictly returns a string. It MUST be parsed via `parseFloat()` before touching any Three.js math.
* **Singularity Prevention:** Standard `OrbitControls` relies on an `up` vector of `(0, 1, 0)`. If the camera pitch reaches exactly $\pi/2$ or $-\pi/2$ (90 degrees up/down), the look vector aligns with the up vector, causing a matrix collapse. Pitch must be hard-clamped to a safe threshold (e.g., $\pm 1.56$ radians, which is $\sim 89.3^\circ$).

## 3. Implementation Phases

### Phase 1: Type Safety and Singularity Clamping
* **Objective:** Prevent `NaN` propagation and Gimbal Lock in the camera matrix.
* **Instructions:**
    1. Locate the inverse handler for the Inside View sliders (e.g., `handleSliderChange`).
    2. Before using the slider values, explicitly cast them to floats:
       ```javascript
       const safeYaw = parseFloat(yawValue);
       let safePitch = parseFloat(pitchValue);
       const safeRoll = parseFloat(rollValue);
       ```
    3. Apply a mathematical clamp to the pitch to prevent the straight-up/straight-down singularity:
       ```javascript
       // Clamp pitch to strictly less than PI/2
       const maxPitch = Math.PI / 2 - 0.01; // ~1.56
       safePitch = Math.max(-maxPitch, Math.min(maxPitch, safePitch));
       ```
    4. Pass these sanitized numbers into the Three.js math:
       ```javascript
       camera.rotation.set(safePitch, safeYaw, safeRoll, 'YXZ');
       const forward = new THREE.Vector3(0, 0, -1);
       forward.applyEuler(camera.rotation);
       controls.target.copy(camera.position).add(forward);
       controls.update();
       ```

### Phase 2: Roll Matrix Protection
* **Objective:** Ensure the Roll axis (Z-rotation) does not conflict with `OrbitControls`' strict `up` vector enforcement.
* **Instructions:**
    1. Standard `OrbitControls` forcefully resets the camera's Z-rotation (Roll) on every `update()` call because it maintains a fixed `(0, 1, 0)` up vector.
    2. If the user requires visual Roll inside the sphere, DO NOT apply it to `controls.target`. Instead, you must manually adjust `camera.up` or visually rotate the scene/sphere wrapper, as `OrbitControls` fundamentally rejects camera roll.
    3. *Agent Directive:* If Roll is causing the matrix crash, temporarily zero out the `safeRoll` parameter in the `camera.rotation.set()` call to isolate the bug, and rely purely on Yaw and Pitch for the `OrbitControls` target projection.

## 4. Final Review
1. Move the Yaw slider rapidly. The screen must not go black.
2. Push the Pitch slider to its maximum top and bottom limits. The camera must look almost straight up/down without the WebGL context crashing.