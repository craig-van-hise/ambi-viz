# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are fixing a playback state collision ("glitch") in the AmbiViz Track Queue. Currently, double-clicking a track while another track is actively playing fails to switch the audio. 

This occurs because the `onTrackSelect` handler (or the equivalent double-click handler in the parent component) fails to explicitly halt the audio engine before loading the new track, causing the `play()` command to be ignored since the engine's state is already `'playing'`.

Your objective is to enforce the strict `stop() -> load() -> play()` sequence on queue selections and add a state guard to prevent rapid-click spamming.

## 2. Technical Decisions & Dependencies
* **Strict Teardown Sequence:** Any action that changes the active track index MUST forcefully call `engine.stop()` before `engine.loadTrack()`. This ensures the active `AudioBufferSourceNode` is destroyed and the `playbackState` is reset to `'stopped'`, allowing the subsequent `play()` call to instantiate the new node.
* **Loading Guard:** If the user double-clicks a track while `engine.playbackState === 'loading'`, the handler must instantly return to prevent parallel `decodeAudioData` promises from colliding.

## 3. Implementation Phases

### Phase 1: Track Selection Teardown & Guard
* **Objective:** Ensure selecting a track from the queue halts current playback and safely loads the new one.
* **Instructions:**
    1. Locate the React component that passes the `onTrackSelect` function to the `TrackQueue` (likely `App.tsx` or a dedicated audio manager hook).
    2. Update the track selection handler to implement the following strict logic:
       ```javascript
       const handleTrackSelect = async (index: number) => {
           // 1. Guard against rapid-click spam
           if (engine.playbackState === 'loading') return;

           // 2. Prevent redundant loads if clicking the already playing track
           if (index === engine.currentIndex && engine.playbackState === 'playing') return;

           try {
               // 3. Forcefully stop the current track (destroys the source node)
               engine.stop();

               // 4. Await the decoding and loading of the new track
               await engine.loadTrack(index);

               // 5. Explicitly start playback
               if (engine.playbackState !== 'error') {
                   engine.play();
               }
           } catch (error) {
               console.error("Failed to play selected track:", error);
           }
       };
       ```
    3. Verify that `TrackQueue.tsx` is strictly using `onDoubleClick={() => onTrackSelect(i)}` on the track list buttons.

### Phase 2: Visual Feedback (Optional but Recommended)
* **Objective:** Ensure the UI immediately communicates to the user that their double-click was registered.
* **Instructions:**
    1. Because `engine.loadTrack()` correctly sets `playbackState` to `'loading'`, ensure the `TrackQueue` or `TransportControls` visually reflects this (e.g., showing a spinner, or applying a `.loading` CSS class to the active track item).
* **TDD Checkpoint:** AGENT INSTRUCTION: Write or update the integration test for track selection. Mock `engine.stop`, `engine.loadTrack`, and `engine.play`. Assert that double-clicking a track while `playbackState === 'playing'` triggers `engine.stop()` exactly once *before* `engine.loadTrack()` is called. Do not proceed until tests PASS.

## 4. Final Review
1. Start playing Track 1.
2. While Track 1 is actively playing, double-click Track 2 in the queue. 
3. Verify that Track 1 immediately stops, the app briefly enters a loading state, and Track 2 begins playing from the beginning.
4. Spam double-click Track 3 multiple times rapidly. Verify the app does not crash or spawn overlapping audio nodes.