# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are debugging a unidirectional data flow bug in the AmbiViz Camera Control Panel. Currently, dragging the 3D canvas correctly updates the React Yaw/Pitch/Roll (YPR) sliders for the "Inside View". However, manually dragging the sliders fails to rotate the camera because `OrbitControls` immediately overwrites `camera.rotation` with its existing `target` vector on the next frame.

Your objective is to make the YPR sliders fully bidirectional by mathematically projecting a new `OrbitControls.target` based on the slider inputs.

## 2. Technical Decisions & Dependencies
* **OrbitControls Override Math:** To rotate an `OrbitControls`-managed camera from the inside (origin), you must translate the Euler angles (Yaw, Pitch, Roll) into a spatial target.
  The math dictates creating a forward vector $(0, 0, -1)$, applying the new Euler rotation to it, and adding it to the camera's current position to derive the new target.
* **Euler Order:** Three.js defaults to `XYZ`. For an interior first-person perspective, you MUST use the `YXZ` order to prevent gimbal lock (Yaw first, then Pitch, then Roll).
* **Feedback Loop Prevention:** Ensure the throttle/debounce logic that syncs the canvas to the UI does not immediately fire a redundant update back to the canvas.

## 3. Implementation Phases

### Phase 1: Forward Vector Target Projection
* **Objective:** Implement the mathematical translation from YPR slider values to a spatial `OrbitControls` target.
* **Instructions:**
    1. Locate the inverse handler that fires when the Inside View YPR sliders change (e.g., `handleSliderChange` in the component or custom hook).
    2. Instead of only setting `camera.rotation.set(...)`, implement the following exact logic to update the controls:
       ```javascript
       // 1. Set the camera's rotation using YXZ order
       camera.rotation.set(pitch, yaw, roll, 'YXZ');
       
       // 2. Project a forward vector based on the new rotation
       const forward = new THREE.Vector3(0, 0, -1);
       forward.applyEuler(camera.rotation);
       
       // 3. Move the OrbitControls target to this new forward position
       controls.target.copy(camera.position).add(forward);
       
       // 4. Force OrbitControls to recalculate
       controls.update();
       ```
    3. Ensure `cameraUIState` (the React state) is updated *before* or simultaneously with this logic so the slider thumb actually moves visually.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write a unit test or integration test for the inverse handler. Mock the `camera` and `controls` objects. Assert that changing the Pitch slider modifies `controls.target.y` and `controls.target.z`. Do not proceed until tests PASS.

### Phase 2: State-Fighting & Throttle Cleanup
* **Objective:** Ensure bidirectional updates do not trigger infinite loops between the UI and the render loop.
* **Instructions:**
    1. Review the event listener attached to `controls.addEventListener('change', ...)` that updates the React UI.
    2. Ensure that manipulating the sliders (which calls `controls.update()`) does not create an endless loop. A simple flag (e.g., `isDraggingSlider = true`) or relying on the existing `Throttle` utility is usually sufficient, but verify the React state only updates if the values actually delta beyond a floating-point threshold (e.g., `Math.abs(old - new) > 0.001`).

## 4. Final Review
1. Set the view mode to Inside.
2. Drag the Yaw slider. Verify the camera pans left/right seamlessly.
3. Drag the Pitch slider. Verify the camera looks up/down without snapping back.
4. Click and drag the 3D canvas directly. Verify the sliders still track the movement accurately.