# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
The `AmbiViz` audio engine has successfully migrated its signal routing to an `AudioWorkletNode` (`obr-processor.js`), which is currently performing a placeholder mono downmix. The objective for this sprint is to integrate the actual compiled OBR WebAssembly (`obr.wasm`) binary. This requires compiling the WASM module on the main thread, passing it to the AudioWorklet via `processorOptions`, handling asynchronous instantiation within the worklet, and setting up the precise memory pointers (heap allocation) required for JavaScript-to-C++ audio buffer handoffs.

## 2. Technical Decisions & Dependencies
* **WASM Loading Architecture**: Fetching and compiling WASM inside an AudioWorklet can cause audio thread stutter or fail due to restricted fetch APIs. **Decision**: The main thread (`OBRDecoder.ts`) will `fetch` and `WebAssembly.compile` the `.wasm` file, then pass the resulting `WebAssembly.Module` to the Worklet via `processorOptions`.
* **Memory Management**: Web Audio processes in chunks of 128 frames. Memory allocation on the WASM heap (`malloc`) must occur *once* during initialization, not during the `process()` loop. You will pre-allocate input buffers (for $N = (order + 1)^2$ channels) and output buffers (for 2 channels).
* **Placeholder C++ API**: Since the exact C++ function signatures of the provided OBR binary might vary, assume standard C-style exports: 
  * `_obr_init(order, sampleRate)`
  * `_obr_process(inputPtr, outputPtr, numFrames)`
  * `_malloc(size)` and `_free(ptr)`

## 3. Implementation Phases

### Phase 4: Main Thread WASM Fetch & Compilation
* **Objective:** Modify `OBRDecoder.ts` to fetch, compile, and inject the WASM module into the Worklet.
* **Instructions:**
    1. In `src/audio/OBRDecoder.ts`, update the `init()` method.
    2. Before creating the `AudioWorkletNode`, add logic to fetch the WASM binary: `const response = await fetch('/obr.wasm');` and `const buffer = await response.arrayBuffer();`.
    3. Compile it: `const wasmModule = await WebAssembly.compile(buffer);`.
    4. Pass `wasmModule` into the Worklet: Update the `AudioWorkletNode` initialization to include `processorOptions: { wasmModule, order: this.order, sampleRate: this.ctx.sampleRate }`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write a mock test for `OBRDecoder.init()` that intercepts the `fetch` call, returns a dummy ArrayBuffer, mocks `WebAssembly.compile`, and verifies that `processorOptions` correctly contains the `wasmModule` and `order`. Do not proceed to Phase 5 until all tests in this checkpoint output a PASS.

### Phase 5: Worklet WASM Instantiation & Memory Allocation
* **Objective:** Instantiate the WASM module inside `obr-processor.js` and allocate stable memory pointers for audio I/O.
* **Instructions:**
    1. In `public/worklets/obr-processor.js`, update the `constructor(options)` to extract `wasmModule`, `order`, and `sampleRate` from `options.processorOptions`.
    2. Define class properties: `this.ready = false;`, `this.inputPtr = null;`, `this.outputPtr = null;`. Calculate the number of input channels: $N = (order + 1)^2$.
    3. Initiate async WASM instantiation: `WebAssembly.instantiate(wasmModule, { env: {} }).then(instance => this.setupWasm(instance, N, sampleRate));`.
    4. Implement `setupWasm(instance, numChannels, sampleRate)`:
        * Store `this.wasm = instance.exports;`.
        * Calculate byte sizes: `const numFrames = 128; const bytesPerFloat = 4;`.
        * Allocate memory: `this.inputPtr = this.wasm._malloc(numChannels * numFrames * bytesPerFloat);` and `this.outputPtr = this.wasm._malloc(2 * numFrames * bytesPerFloat);`.
        * Initialize the renderer: `this.wasm._obr_init(order, sampleRate);`.
        * Set `this.ready = true;`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write a Worklet unit test (using a simulated Worklet environment or isolated JS test) that provides a mock `wasmModule`. Verify that `setupWasm` successfully calculates the correct byte sizes for $N$ channels at 128 frames and calls `_malloc` twice. Do not proceed to Phase 6 until all tests in this checkpoint output a PASS.

### Phase 6: The Audio Processing Loop (C++ Interop)
* **Objective:** Route the 128-frame Web Audio arrays into the WASM heap, execute the OBR render, and extract the binaural output.
* **Instructions:**
    1. In `obr-processor.js`, update the `process(inputs, outputs, parameters)` method.
    2. Add a guard clause: `if (!this.ready) return true;` (silently output nothing/zeroes until WASM is loaded to prevent crashes).
    3. Retrieve the `Float32Array` view of the WASM memory: `const heap = new Float32Array(this.wasm.memory.buffer);`.
    4. **Input Copy:** Loop through `inputs[0]` (the $N$ input channels). For each channel `c` and frame `i`, copy the Web Audio float into the WASM heap at the correct index (offsetting by `this.inputPtr / 4`).
    5. **Process:** Call `this.wasm._obr_process(this.inputPtr, this.outputPtr, 128);`.
    6. **Output Copy:** Loop through `outputs[0]` (the 2 output channels: Left and Right). Copy the processed floats from the WASM heap (offsetting by `this.outputPtr / 4`) back into the Web Audio output arrays.
    7. Return `true` to keep the processor alive.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write an isolated test for the `process` loop. Mock the `inputs` (e.g., a 4-channel array of 128 frames) and `outputs` (a 2-channel array). Assert that when `this.ready` is true, the input arrays are correctly copied to the mock heap, the `_obr_process` spy is called, and data is copied back to the `outputs`. Do not proceed to Final Review until all tests in this checkpoint output a PASS.

## 4. Final Review
1. Verify `package.json` and build tools correctly serve static `.wasm` files from the `/public` directory (Vite handles this natively, but verify).
2. Ensure there are no memory leaks in the worklet (e.g., `_malloc` being called inside the `process` loop).
3. Confirm that the $N$ channel calculation maps correctly: Order 1 = 4ch, Order 2 = 9ch, Order 3 = 16ch.