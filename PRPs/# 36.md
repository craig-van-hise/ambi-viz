# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
**Project:** AmbiViz (Ambisonic Visualization Application)
**Current State:** PRP #25 successfully implemented the 3DOF orientation matrix, including pitch inversion, roll via `camera.up`, and a hard origin lock. The HeadTrackingService currently drives both the 3D visual camera and the Google Open Binaural Renderer (OBR) via a SharedArrayBuffer (SAB).
**Objective:** Correct a spatial audio rendering defect where the audio Yaw axis is inverted relative to physical head movement (turning head left causes audio to pan left, instead of panning right to simulate a fixed environmental sound source). The visual camera yaw is correct; only the audio path requires inversion. 

## 2. Technical Decisions & Dependencies
* **Architectural Pattern (Audio/Visual Decoupling):** We must fork the orientation state before it is dispatched to the OBR Worklet. The 3D scene (Three.js) will continue to use the current Quaternion, but the OBR SAB must receive a Yaw-inverted Quaternion.
* **Mathematical Implementation:** 1. Extract the current Euler angles from the source quaternion (using Three.js `Euler` with standard 'YXZ' order).
  2. Apply the inversion: $Yaw_{audio} = -Yaw_{tracker}$.
  3. Reconstruct $Q_{audio}$ from the modified Euler angles.
  4. Write $Q_{audio}$ to the SharedArrayBuffer, leaving $Q_{visual}$ intact for the `OrbitControls` and UI sliders.
* **Target Files:** `src/HeadTrackingService.ts` (or the specific bridge file where the SAB is updated, as implemented in PRP #23) and its corresponding `.test.ts` file.

## 3. Implementation Phases

### Phase 1: Test-Driven Development (TDD) for Yaw Inversion
* **Objective:** Establish failing tests for the new audio-specific quaternion calculation before modifying the core bridge logic.
* **Instructions:** Locate the unit tests for the tracking-to-audio bridge (likely in `HeadTrackingService.test.ts` or `AudioEngine.test.ts`). Add tests to ensure that the quaternion written to the SAB represents an inverted Yaw compared to the visual tracking state.
* **TDD Checkpoint:**
    * **Test Case 1:** [Given a positive Yaw input (e.g., rotating Left by 45 degrees), When the state is processed for audio, Then the resulting Euler Y component extracted from the audio quaternion must be exactly -45 degrees (-$\pi/4$ radians).]
    * **Test Case 2:** [Given a complex 3DOF rotation (Pitch: 10°, Yaw: -30°, Roll: 5°), When processed, Then the audio quaternion must accurately reflect (Pitch: 10°, Yaw: 30°, Roll: 5°) without introducing gimbal lock or mutating the pitch/roll values.]
    * **Mocking Requirements:** Mock the `SharedArrayBuffer` and the Float32Array view used to pass the quaternion to the OBR worklet to inspect the output values.
    * **AGENT INSTRUCTION:** "Write and execute these tests in the project's testing framework. Ensure they fail initially. Do not proceed to Phase 2 until all tests in this checkpoint output a PASS."

### Phase 2: Implement Audio Path Yaw Decoupling
* **Objective:** Apply the mathematical fix to the SAB write loop.
* **Instructions:** 1. Locate the render loop or tracking callback where the WebCam/ESKF quaternion is written to the Audio SAB.
  2. Instantiate a temporary Three.js `Euler` and `Quaternion` object outside the loop to avoid garbage collection overhead per frame.
  3. Inside the loop, before writing to the SAB:
     - Set the temporary Euler from the base tracking quaternion (ensure the order matches your existing UI, likely 'YXZ').
     - Negate the Y-axis value (Yaw).
     - Set the temporary Audio Quaternion from this modified Euler.
  4. Write the $x, y, z, w$ components of this *Audio Quaternion* to the SAB.
  5. Ensure the visual UI (React sliders) and Three.js camera continue to receive the unmodified (non-yaw-inverted) quaternion.
* **TDD Checkpoint:**
    * **Test Case 1:** [Given the application is running, When the SAB is polled after a tracking update, Assert the values in the SAB perfectly match the newly implemented $Q_{audio}$ calculation.]
    * **AGENT INSTRUCTION:** "Run the full Vitest suite. Ensure all 60+ previous tests (including the PRP #25 Pitch and Roll constraints) still pass alongside your new Yaw tests."

## 4. Final Review
* **AGENT INSTRUCTION:** 1. Verify that `HeadTrackingService.ts` (or equivalent) does not instantiate new objects (like `new THREE.Euler()`) inside the high-frequency polling/render loop. All helper objects must be declared at the class/module scope to maintain performance.
  2. Confirm that the UI sliders still accurately reflect the user's physical head movement (turning left moves the Yaw slider left) while the audio engine receives the inverted coordinate.
  3. Check the `PROJECT_STATE.md` to ensure no regressions were introduced to the "Singularity Prevention" or "Warp Zone Hardening" features.