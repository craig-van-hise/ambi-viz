# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are resolving a one-way data binding regression in the AmbiViz Camera Control Panel. Currently, the Yaw/Pitch/Roll (YPR) sliders update correctly when the user drags the canvas (via `OrbitControls` mouse events). However, when the `HeadTrackingService` programmatically drives the camera rotation via webcam data, the sliders remain static.

Your objective is to decouple the React UI synchronization from the `OrbitControls` `'change'` event and move it into the main WebGL render loop (`requestAnimationFrame`) so that it universally captures all camera mutations regardless of their source.

## 2. Technical Decisions & Dependencies
* **Universal Polling via Render Loop:** Do not rely on `controls.addEventListener('change', ...)`. Instead, you MUST invoke the throttled UI state updater directly inside the main animation loop (e.g., `tick()`, `animate()`, or `useFrame` if using React Three Fiber).
* **Quaternion to Euler Conversion:** Head tracking typically applies pure Quaternions to the camera. To ensure the YPR sliders read accurate values, you must read from `camera.rotation` (which Three.js auto-updates from quaternions if matrix auto-update is on), ensuring the Euler order is explicitly evaluated as `YXZ` for the interior view.
* **React Throttle Safety:** Because the render loop fires at 60+ FPS, the `Throttle.ts` utility is absolutely mandatory here. Throttle the React state dispatch to roughly 50ms-100ms.

## 3. Implementation Phases

### Phase 1: Detach OrbitControls Listener
* **Objective:** Remove the existing flawed event listener.
* **Instructions:**
    1. Locate where the React state sync was previously implemented (likely a `useEffect` in the component wrapping `AmbiScene` or inside `AmbiScene.ts`).
    2. Remove or comment out the `controls.addEventListener('change', throttledUpdate)` logic.

### Phase 2: Implement Render-Loop Polling
* **Objective:** Capture camera state universally on every frame, safely throttled.
* **Instructions:**
    1. Locate the main Three.js animation loop (`requestAnimationFrame` callback, often named `animate`, `render`, or `tick` in `AmbiScene.ts`).
    2. Ensure `camera.rotation.reorder('YXZ')` is active or inherently assumed for the Inside view to prevent Gimbal lock misreadings.
    3. Inside the render loop, execute the throttled UI updater:
       ```javascript
       // In the render loop (e.g., AmbiScene.animate)
       
       // Example logic using the existing Throttle utility:
       throttledUpdateUIState(() => {
           // Ensure we are reading the latest Euler angles driven by the HeadTracker's quaternion
           const yaw = camera.rotation.y;
           const pitch = camera.rotation.x;
           const roll = camera.rotation.z;
           
           // Dispatch to React state (e.g., via a callback passed from App.tsx or a store)
           onCameraStateChange({ yaw, pitch, roll, x: camera.position.x, y: camera.position.y, z: camera.position.z });
       });
       ```
    4. *Agent Directive:* If `CameraControlPanel.tsx` uses a React context or Zustand/Redux store, ensure the render loop has access to the throttled setter function.

### Phase 3: State-Fighting Prevention (Head Tracking vs. Sliders)
* **Objective:** Ensure the Head Tracker and the Manual Sliders do not violently overwrite each other in the same frame.
* **Instructions:**
    1. When the user is *actively dragging* the manual YPR sliders, you must temporarily pause the HeadTracking application to the camera, OR pause the render-loop UI polling.
    2. Implement a simple boolean flag (e.g., `isUserDraggingSlider = true`) during the slider's `onPointerDown` or `onChange` event, and set it to `false` on `onPointerUp`.
    3. If `isUserDraggingSlider` is true, the render loop should bypass the UI state update to prevent the thumb from jumping back and forth.

## 4. Final Review
1. Enable webcam head tracking and move your head. Verify that the YPR sliders move autonomously in real-time, mirroring your head movements.
2. Disable head tracking and drag the 3D canvas with your mouse. Verify the sliders still track the mouse movements correctly.
3. Grab one of the YPR sliders with your mouse while head tracking is active. Ensure the slider thumb does not violently glitch or fight your mouse input.