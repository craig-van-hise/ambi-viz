# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
The `AmbiViz` application currently relies on `JSAmbisonics` for binaural rendering of Ambisonic audio signals (Order 1-3) via a `ConvolverNode`-based `binDecoder`. The objective is to remove the `JSAmbisonics` dependency for binaural rendering and replace it with the **Open Binaural Renderer (OBR)**. The visualization signal chain—which relies on `RawCoefAnalyser` extracting covariance matrices and RMS coefficients—must remain completely intact and undisrupted.

## 2. Technical Decisions & Dependencies
* **Web Audio Architecture**: OBR (a C++ library by Google) must run in an `AudioWorkletNode` to process the multi-channel Ambisonic stream efficiently without blocking the main thread.
* **Signal Routing**: The new signal chain will be: `AudioBufferSourceNode` -> `RawCoefAnalyser.in` -> `RawCoefAnalyser.out` -> `OBRDecoder.in` (GainNode) -> `OBRWorkletNode` -> `OBRDecoder.out` (GainNode) -> `audioCtx.destination`.
* **WASM/Worklet Abstraction**: Since the exact OBR WASM bindings are handled outside this scope, you will build a robust `OBRDecoder` class and an `obr-processor.js` Worklet boilerplate. This decouples the audio engine from the specific OBR WASM initialization, allowing seamless injection of the compiled OBR binary later.
* **Dependency Removal**: `ambisonics.binDecoder` and `ambisonics.HRIRloader_local` must be fully purged from `AudioEngine.ts`.

## 3. Implementation Phases

### Phase 1: Implement the OBR AudioWorkletProcessor Boilerplate
* **Objective:** Create the foundational Worklet processor script that will host the OBR rendering logic.
* **Instructions:**
    1. Create a new file: `public/worklets/obr-processor.js`.
    2. Implement an `AudioWorkletProcessor` named `OBRProcessor`.
    3. In the `constructor`, accept `options.processorOptions.order` to determine the channel count (`(order + 1)^2`).
    4. In the `process` method, map `inputs[0]` (N channels) to `outputs[0]` (2 channels). For the initial boilerplate, implement a simple downmix (copying channel 0/W to output Left and Right) to ensure audio flows before the WASM binary is fully integrated.
    5. Call `registerProcessor('obr-processor', OBRProcessor);`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Since AudioWorklets are difficult to test in a Node environment, write a static analysis test or basic mock test verifying `obr-processor.js` exports a valid processor registration. Do not proceed to Phase 2 until all tests in this checkpoint output a PASS.

### Phase 2: Create the `OBRDecoder` Wrapper Class
* **Objective:** Encapsulate the WorkletNode creation into a class with the same `.in` and `.out` interface as the old `binDecoder`.
* **Instructions:**
    1. Create `src/audio/OBRDecoder.ts`.
    2. Define class `OBRDecoder` taking `(ctx: AudioContext, order: number)` in its constructor.
    3. Create `this.in` and `this.out` as `GainNode`s for stable routing.
    4. Implement an `async init()` method that:
        * Awaits `this.ctx.audioWorklet.addModule('/worklets/obr-processor.js')`.
        * Instantiates `new AudioWorkletNode(this.ctx, 'obr-processor', { ... })` with `channelCount` set to the Ambisonic channel total, `channelCountMode: 'explicit'`, `channelInterpretation: 'discrete'`, and `outputChannelCount: [2]`.
        * Connects `this.in` to the WorkletNode, and the WorkletNode to `this.out`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write unit tests verifying that `OBRDecoder` correctly initializes its inner `GainNode`s, exposes `in` and `out`, and has an `init()` method. Mock the `AudioContext.audioWorklet` for testing. Do not proceed to Phase 3 until all tests in this checkpoint output a PASS.

### Phase 3: Refactor `AudioEngine.ts` Signal Chain
* **Objective:** Replace JSAmbisonics with the new OBR module in the main audio engine.
* **Instructions:**
    1. In `src/audio/AudioEngine.ts`, import `OBRDecoder`.
    2. Remove all references to `ambisonics.binDecoder` and `ambisonics.HRIRloader_local`.
    3. Replace the `this.binDecoder` property with `this.obrDecoder: OBRDecoder | null = null;`.
    4. In the `setupGraph(buffer)` method, instantiate `this.obrDecoder = new OBRDecoder(this.audioCtx, this.order);` and immediately `await this.obrDecoder.init();`.
    5. Update graph connections: `this.rawAnalyser.out.connect(this.obrDecoder.in);` and `this.obrDecoder.out.connect(this.audioCtx.destination);`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write integration tests verifying the `AudioEngine` graph setup correctly inserts `OBRDecoder` into the chain. Assert that `ambisonics` binaural components are no longer called. Do not proceed to the final review until all tests in this checkpoint output a PASS.

## 4. Final Review
1. Run `npm run build` and `npm run lint` to ensure no lingering TypeScript errors from the removed `ambisonics` types.
2. Verify that `RawCoefAnalyser.ts` and its `getCovarianceMatrix()` logic are entirely unaffected by this downstream routing change.
3. Clean up unused imports in `AudioEngine.ts`.