# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
This phase addresses critical regressions and mapping failures in the 3DOF orientation matrix and the Inside Camera constraints. The current implementation suffers from an inverted Pitch axis, a completely dead Roll axis (failing across head-tracking, UI, and audio renderer integration), and an unmoored Inside Camera that translates away from the origin `(0, 0, 0)`. The objective is to enforce strict origin locking, invert the Pitch logic, and plumb the Roll axis end-to-end from the tracking interface to the OBR WASM renderer and Three.js camera.

## 2. Technical Decisions & Dependencies
To eliminate cognitive load and prevent architectural drift, the agent MUST implement the following mathematical and architectural decisions:

* **Pitch Inversion Logic:** The pitch input from the `HeadTrackingService` or SAB must be multiplied by $-1$ before it is dispatched to the React UI, the OBR Renderer, and the Three.js camera.
* **Three.js Roll Axis Implementation:** `OrbitControls` natively ignores `camera.rotation.z` (Roll). To visually represent Roll in the 3D canvas, you MUST dynamically compute and update the `camera.up` vector before calling `controls.update()`.
    * **Math:** Given a roll angle $\gamma$ (in radians), the new up vector is computed as:
        $\mathbf{U} = [-\sin(\gamma), \cos(\gamma), 0]$
    * Apply this via `camera.up.set(-Math.sin(roll), Math.cos(roll), 0).normalize();`
* **Absolute Origin Lock (Inside View):** A simple flag (`enablePan = false`) is insufficient due to floating-point drift and zoom regressions. You MUST enforce a strict overwrite inside the `AmbiScene.animate` render loop:
    * `if (this.viewMode === 'inside') { this.camera.position.set(0, 0, 0); }`
    * Upon initializing Inside View, the target MUST be projected exactly 1 unit forward along the Z-axis (e.g., `(0, 0, -1)`) to fix the backward-spawning bug.
* **Type Safety:** All instances of `ROLL` and `roll` must be normalized to a standard `number` (float) type. Explicitly coerce UI slider string values via `parseFloat()` before bridging to the SAB or Renderer.

## 3. Implementation Phases

### Phase 1: Inside Camera Lock & Spawn Correction
* **Objective:** Eradicate all translation capabilities for the Inside Camera and ensure it spawns facing the correct forward vector.
* **Instructions:**
    1. Open `src/visualizer/AmbiScene.ts`.
    2. Locate the view mode transition logic (e.g., `setViewMode('inside')`).
    3. Force the camera position to absolute zero: `this.camera.position.set(0, 0, 0);`.
    4. Force the `OrbitControls` target exactly 1 unit forward: `this.controls.target.set(0, 0, -1);` (adjust sign if your forward vector is $+Z$).
    5. Set `this.controls.enablePan = false;` and `this.controls.enableZoom = false;` when in inside mode.
    6. In the `animate()` loop, add a hard guard: `if (this.isInsideView) { this.camera.position.set(0, 0, 0); }` to prevent control interpolation drift.
* **TDD Checkpoint:** * *AGENT INSTRUCTION: Write and execute these tests. Do not proceed to Phase 2 until all tests in this checkpoint output a PASS.*
    * Write a test in `CameraControl.test.ts` (or equivalent) asserting that when `viewMode` is `'inside'`, `camera.position` strictly equals `(0,0,0)` before and after a mock `controls.update()` tick.

### Phase 2: Pitch Inversion & Roll Data Pipeline
* **Objective:** Fix the inverted Pitch and bridge the dead Roll parameter from the UI/Tracker down to the renderer pipeline.
* **Instructions:**
    1. Open `src/tracking/HeadTrackingService.ts` (or the exact module bridging tracking data to the UI/SAB).
    2. Invert the Pitch value: `const correctedPitch = rawPitch * -1;`.
    3. Ensure the `roll` variable is accurately extracted from the ESKF output and written to the SharedArrayBuffer (SAB).
    4. Open `src/components/CameraControlPanel.tsx` (and `App.tsx` if state is hoisted). Verify the Roll slider is fully hooked up to the `setRoll` dispatch, and that `parseFloat(value)` is used to prevent string contamination.
* **TDD Checkpoint:**
    * *AGENT INSTRUCTION: Write and execute these tests. Do not proceed to Phase 3 until all tests in this checkpoint output a PASS.*
    * Write a test simulating upward head movement and assert that the resulting UI Pitch state and SAB Pitch float are now negative.
    * Write a test asserting that updating the Roll slider updates the React state and correctly writes a float to the SAB.

### Phase 3: Renderer & Visual Sync (The OBR & Three.js Bridge)
* **Objective:** Consume the corrected Pitch and the new Roll data in both the audio spatializer and the visualizer.
* **Instructions:**
    1. Open `src/audio/OBRDecoder.ts`. Locate the method updating rotation (e.g., `updateRotation(yaw, pitch, roll)`).
    2. Verify the WASM binding (`obr_wrapper.cpp` / `obr.wasm`) accepts the `roll` parameter. Pass the `roll` value explicitly to the C++ WebAssembly layer.
    3. Open `src/visualizer/AmbiScene.ts`. In the `animate` loop (or camera update method), extract the `roll` value from the SAB or UI state.
    4. Implement the dynamic `camera.up` math dictated in Section 2:
       `this.camera.up.set(-Math.sin(roll), Math.cos(roll), 0).normalize();`
    5. Ensure `this.camera.lookAt(this.controls.target);` is called after applying the up-vector rotation to lock the visual roll.
* **TDD Checkpoint:**
    * *AGENT INSTRUCTION: Write and execute these tests. Do not proceed to the Final Review until all tests in this checkpoint output a PASS.*
    * Write a test in `AmbiScene.test.ts` mocking a $90^\circ$ ($\pi/2$ radians) Roll input and assert that `camera.up.x` approaches `-1` and `camera.up.y` approaches `0`.
    * Write a test in `OBRDecoder.test.ts` spying on the WASM `set_rotation` method to assert it is called with 3 valid float arguments (Yaw, Pitch, Roll).

## 4. Final Review
1. Launch the application via `npm run dev`.
2. Toggle to "Inside View". Verify the camera spawns facing forward (not the reverse side of the visualizer) and that manual panning/zooming does not displace the camera from `(0,0,0)`.
3. Move the Pitch slider up (or tilt head up). Verify the 3D view tilts *up* and the audio field rotates accordingly.
4. Move the Roll slider (or tilt head side-to-side). Verify the `camera.up` vector correctly rolls the 3D scene and that the OBR spatializer shifts the binaural field.
5. Execute the full Vitest suite to ensure no regressions in the ESKF or JIT Web Audio pipelines.