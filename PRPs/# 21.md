# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
You are fixing a critical mathematical singularity ("Warp Zone" / Black Screen) in the AmbiViz Camera Controls. 

The issue stems from `OrbitControls` attempting to calculate spherical coordinates when `camera.position` and `controls.target` are both set to `(0, 0, 0)`, causing a division-by-zero radius explosion. Additionally, `OrbitControls` is attempting to drag the camera away from the origin to satisfy an old orbital distance.

Your objective is to strictly isolate the Inside Camera's spatial logic: enforcing a hard-locked origin position, projecting a safe 1-unit target radius, and clamping the Pitch.

## 2. Technical Decisions & Dependencies
* **Radius Explosion Prevention:** For the Inside View, `controls.target` MUST NEVER equal `(0, 0, 0)` while the camera is at `(0, 0, 0)`. It must always be projected outwards (e.g., radius of 1).
* **Position Lock:** `OrbitControls.update()` will try to mutate `camera.position` to satisfy orbital mechanics. You must aggressively reset `camera.position.set(0, 0, 0)` *immediately after* calling `controls.update()` when in the Inside View.
* **Pitch Clamping:** Hard-clamp Pitch to $\pm 1.56$ radians to prevent the up-vector Gimbal Lock.

## 3. Implementation Phases

### Phase 1: Inside View Transition Hardening
* **Objective:** Ensure switching from Outside to Inside initializes a safe, non-zero target radius.
* **Instructions:**
    1. Locate the view mode toggle logic (switching from Outside to Inside).
    2. Before calling `controls.update()`, explicitly set:
       ```javascript
       camera.position.set(0, 0, 0);
       // Push the target exactly 1 unit forward on the Z-axis to prevent distance=0
       controls.target.set(0, 0, -1); 
       controls.update();
       ```

### Phase 2: YPR Slider Math & Position Locking
* **Objective:** Prevent the sliders from slingshotting the camera by projecting a unit-vector target and overriding `OrbitControls` positional shifts.
* **Instructions:**
    1. Locate the inverse handler for the Inside View YPR sliders (`handleSliderChange`).
    2. Replace the inside-view update logic with this exact, safe mathematical sequence:
       ```javascript
       // 1. Coerce strings to floats and clamp pitch safely
       const safeYaw = parseFloat(yawValue);
       const maxPitch = Math.PI / 2 - 0.01; // ~1.56 radians
       const safePitch = Math.max(-maxPitch, Math.min(maxPitch, parseFloat(pitchValue)));
       const safeRoll = 0; // Force Roll to 0 for OrbitControls stability

       // 2. Temporarily lock camera to origin
       camera.position.set(0, 0, 0);

       // 3. Set the Euler rotation
       camera.rotation.set(safePitch, safeYaw, safeRoll, 'YXZ');

       // 4. Project the target exactly 1 unit away based on the new rotation
       const forward = new THREE.Vector3(0, 0, -1);
       forward.applyEuler(camera.rotation);
       controls.target.copy(forward);

       // 5. Update controls
       controls.update();

       // 6. CRITICAL: Force the camera position back to the origin. 
       // OrbitControls will try to displace it based on old radius caches.
       camera.position.set(0, 0, 0);
       ```

### Phase 3: Synchronize UI to Camera
* **Objective:** Ensure the React UI accurately reflects these clamped values.
* **Instructions:**
    1. In the Throttle/debounce listener that updates the React state from the camera, ensure you are reading `camera.rotation.y` and `camera.rotation.x`. 
    2. Ensure no floating point `NaN` values are passed to React state (fallback to `0` if `NaN` is detected).

## 4. Final Review
1. Switch between Inside and Outside views. The screen must not go black.
2. In the Inside view, drag the Yaw and Pitch sliders. The camera must look around smoothly.
3. Verify that the sphere environment no longer drifts into the distance (the camera remains locked at the center `0, 0, 0`).