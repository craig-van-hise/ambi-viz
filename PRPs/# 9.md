

```text
**OBJECTIVE: INJECT WASM SIGNAL DIAGNOSTIC PROBE**
The `obr-processor.js` is outputting absolute silence. We must determine if the C++ engine is outputting `0.0`, outputting `NaN`, or if the JavaScript input array is starved.

**INSTRUCTIONS: Add Diagnostic Logging to `obr-processor.js`**

1. **Add a Frame Counter:**
   In the `OBRProcessor` constructor, add `this.diagnosticCounter = 0;`.

2. **Inject the Probe in `process()`:**
   Directly after `this.wasm._obr_process(...)` and the output array mapping, add the following diagnostic logic to sample the exact floating-point values at the 100th processing block (approx. 0.2 seconds after audio starts).

   ```javascript
   // 3. Copy from WASM Heap to outputs
   if (output[0]) output[0].set(this.wasm.HEAPF32.subarray(this.outOffset, this.outOffset + 128));
   if (output[1]) output[1].set(this.wasm.HEAPF32.subarray(this.outOffset + 128, this.outOffset + 256));

   // --- DIAGNOSTIC PROBE ---
   if (this.ready && input[0] && this.diagnosticCounter < 100) {
       this.diagnosticCounter++;
       if (this.diagnosticCounter === 100) {
           console.log("=== WASM AUDIO DIAGNOSTIC ===");
           console.log("INPUT CH 0 (First 5 frames):", input[0].slice(0, 5));
           console.log("WASM OUTPUT LEFT (First 5 frames):", output[0].slice(0, 5));
           
           // Check for NaNs
           const hasNaN = isNaN(output[0][0]);
           if (hasNaN) console.error("CRITICAL: WASM is outputting NaN. Audio graph is muted.");
           
           // Check for absolute silence
           const isSilent = output[0][0] === 0 && output[0][1] === 0 && output[0][2] === 0;
           if (isSilent && input[0][0] !== 0) console.error("CRITICAL: WASM is eating the signal (Output is 0.0). C++ Engine likely missing HRTF/AudioElement initialization.");
       }
   }
   // ------------------------
   
   return true;

```

3. **Explicit AudioNode Channel Config:**
In `src/audio/AudioEngine.ts` (or wherever `new AudioWorkletNode` is called), explicitly force the channel count mode so the browser doesn't downmix the 4/9/16 Ambisonic channels before they hit the Worklet:
```typescript
const obrNode = new AudioWorkletNode(this.audioCtx, 'obr-processor', { 
    processorOptions: { order: this.order, sampleRate: this.audioCtx.sampleRate },
    channelCount: (this.order + 1) * (this.order + 1),
    channelCountMode: 'explicit',
    channelInterpretation: 'discrete',
    outputChannelCount: [2] 
});

```



**TDD CHECKPOINT**
Implement the diagnostic probe and the explicit `AudioWorkletNode` channel config. Tell the user to open the browser DevTools (F12), drop an audio file, and report the exact console output of `=== WASM AUDIO DIAGNOSTIC ===`.

```
