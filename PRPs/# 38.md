# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
**Project:** AmbiViz (Ambisonic Visualization Application)
**Current State:** The previous prompt successfully inverted the pitch (X-axis) for the primary visual gaze indicator (the Green Arrow). However, the visual debugging tool used for ESKF velocity anticipation—specifically the "Ghost/Predicted Arrow" (Shadow Arrow)—was excluded from this update. Consequently, the two arrows currently mirror each other on the pitch axis.
**Objective:** Synchronize the Pitch (X-axis) inversion of the Ghost/Shadow Arrow with the primary Green Arrow. Both meshes must react identically to head pitch (tilting head down moves both arrows down) to accurately serve their purpose of debugging predictive tracking latency and jitter.

## 2. Technical Decisions & Dependencies
* **Architectural Pattern (Mesh-Level Decoupling Parity):** The inversion logic applied to the Green Arrow must be replicated for the Ghost Arrow. This occurs purely in the 3D rendering layer (expected location: `src/visualizer/AmbiScene.ts` or the dedicated ESKF debugging visualizer).
* **Mathematical Implementation:**
  1. Intercept the raw/predicted tracking quaternion before it is applied to the Ghost Arrow mesh.
  2. Convert the quaternion to Euler angles using Three.js `Euler` (order 'YXZ').
  3. Apply the inversion: $Pitch_{ghost} = -Pitch_{raw/predicted}$ (negate the X-axis component).
  4. Reconstruct the quaternion and apply it strictly to the Ghost Arrow mesh.
* **Performance Guardrails:** To prevent frame drops and garbage collection (GC) stutter during the 60+ FPS render loop, you must reuse the class-scoped `THREE.Euler` and `THREE.Quaternion` objects instantiated during the previous Green Arrow fix, or create dedicated class-scoped instances for the Ghost Arrow. DO NOT use `new` inside `animate()` or `update()`.

## 3. Implementation Phases

### Phase 1: Test-Driven Development (TDD) for Ghost Arrow Synchronization
* **Objective:** Establish failing tests ensuring the Ghost Arrow mesh strictly adheres to the same pitch-inversion rules as the primary Green Arrow.
* **Instructions:** Locate the visualizer unit tests (`AmbiScene.test.ts` or `ESKF.test.ts` if the debug mesh is managed there). Add tests that supply a raw/predicted quaternion and verify the Ghost Arrow's final X-axis rotation.
* **TDD Checkpoint:**
    * **Test Case 1:** [Given a predicted tracking update with a positive Pitch (e.g., $\pi/4$), When the scene updates the Ghost Arrow, Assert that the Ghost Arrow's local Euler X rotation is exactly $-\pi/4$.]
    * **Test Case 2:** [Given simultaneous updates to both the primary Green Arrow and the Ghost Arrow with identical quaternions, Assert that their resulting `quaternion.x` and `quaternion.w` (or Euler X) values are perfectly identical (no mirroring).]
    * **Mocking Requirements:** Mock the Three.js Scene, the Green Arrow mesh, and the Ghost/Shadow Arrow mesh.
    * **AGENT INSTRUCTION:** "Write and execute these tests in the project's testing framework. Ensure they fail initially. Do not proceed to Phase 2 until all tests in this checkpoint output a PASS."

### Phase 2: Implement Ghost Arrow Pitch Inversion
* **Objective:** Apply the mathematical fix to the Ghost Arrow's render loop update, ensuring perfect alignment with the primary gaze indicator.
* **Instructions:** 1. Open `src/visualizer/AmbiScene.ts` (or the file responsible for updating the debugging arrows).
  2. Locate the render loop logic where the Ghost Arrow (often named `ghostArrowMesh`, `predictedArrowMesh`, or `shadowArrow`) receives its orientation from the raw/ESKF tracking state.
  3. Utilize class-level temporary `THREE.Euler` and `THREE.Quaternion` variables.
  4. In the update sequence for the Ghost Arrow:
     - Set the temporary Euler from the Ghost Arrow's target quaternion (order 'YXZ').
     - Negate the `x` property.
     - Set the temporary Quaternion from the Euler.
     - Apply this transformed Quaternion to the Ghost Arrow mesh.
* **TDD Checkpoint:**
    * **Test Case 1:** [Given the application is running in 'Tracking' mode with ESKF tuning active, When the user pitches their head, Assert that both the primary Green Arrow and the Ghost Arrow move in the exact same vertical direction.]
    * **AGENT INSTRUCTION:** "Run the full Vitest suite. Ensure all previous tests (including the Audio Yaw decoupling and Green Arrow pitch inversion) pass flawlessly."

## 4. Final Review
* **AGENT INSTRUCTION:** 1. Audit the `update()`/`animate()` loop in `AmbiScene.ts` to strictly guarantee zero `new THREE.Euler()` or `new THREE.Quaternion()` allocations per frame.
  2. Verify visually in the browser that the Ghost Arrow (representing raw/predicted state) no longer mirrors the Green Arrow on the Y-axis (vertical screen space), but overlaps or tightly follows it based on the ESKF velocity anticipation settings.
  3. Confirm the core `camera.quaternion` and the Audio `SharedArrayBuffer` remain isolated from these mesh-specific cosmetic transformations.