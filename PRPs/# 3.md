# Product Requirements Prompt (PRP)

## 1. Project Context & Objectives
The `AmbiViz` audio engine successfully runs the Open Binaural Renderer (OBR) within an `AudioWorkletNode` using WebAssembly. The current objective is to implement a dynamic HRTF loading system. The main thread must fetch binary `.sofa` files, transmit them to the AudioWorklet via the `MessagePort`, allocate temporary WASM memory, hand the byte array to the C++ engine for parsing, and expose a React UI for the user to switch between different HRTF models in real-time.

## 2. Technical Decisions & Dependencies
* **Thread Communication**: `processorOptions` is strictly for initialization. Real-time HRTF swapping requires using the `AudioWorkletNode.port.postMessage()` API.
* **WASM Memory Handoff**: SOFA files are binary. The worklet will receive an `ArrayBuffer`, allocate a `Uint8Array` on the WASM heap, copy the bytes, and pass the pointer to the C++ parser. 
* **Assumed C++ API**: Assume the OBR WASM binary exports `_obr_load_sofa(ptr, size)`. Since the C++ engine will parse and store the state internally, the allocated memory for the raw `.sofa` file MUST be freed immediately after the call using `_free(ptr)` to prevent severe memory leaks.
* **UI Integration**: A simple dropdown selector in the React layer will trigger the fetch and load process.

## 3. Implementation Phases

### Phase 7: Main Thread SOFA Fetching & Port Communication
* **Objective:** Extend `OBRDecoder.ts` to fetch binary `.sofa` files and send them to the worklet.
* **Instructions:**
    1. In `src/audio/OBRDecoder.ts`, ensure you have a reference to the created `AudioWorkletNode` (e.g., `this.workletNode`).
    2. Implement an `async loadSofa(url: string)` method.
    3. Inside `loadSofa`, `fetch` the provided URL and extract the `ArrayBuffer`: `const response = await fetch(url); const buffer = await response.arrayBuffer();`.
    4. Send the buffer to the worklet: `this.workletNode.port.postMessage({ type: 'LOAD_SOFA', payload: buffer });`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write a unit test for `OBRDecoder.loadSofa`. Mock the global `fetch` to return a dummy `ArrayBuffer`. Spy on `workletNode.port.postMessage` and verify it is called with the correct `{ type, payload }` structure. Do not proceed to Phase 8 until all tests in this checkpoint output a PASS.

### Phase 8: Worklet WASM Memory Allocation & C++ Handoff
* **Objective:** Intercept the SOFA payload in the worklet, copy it to the WASM heap, and execute the C++ parser.
* **Instructions:**
    1. In `public/worklets/obr-processor.js`, add a message listener inside the `constructor`: `this.port.onmessage = (event) => this.handleMessage(event);`.
    2. Implement `handleMessage(event)` to listen for `event.data.type === 'LOAD_SOFA'`.
    3. Extract the `ArrayBuffer` payload and calculate its size in bytes.
    4. Allocate memory: `const ptr = this.wasm._malloc(size);`.
    5. Create a `Uint8Array` view into the WASM heap and copy the data: `new Uint8Array(this.wasm.memory.buffer, ptr, size).set(new Uint8Array(event.data.payload));`.
    6. Execute the C++ parser: `this.wasm._obr_load_sofa(ptr, size);`.
    7. **CRITICAL:** Free the temporary memory immediately: `this.wasm._free(ptr);`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write an isolated unit test for `handleMessage`. Manually trigger the method with a mock `{ type: 'LOAD_SOFA', payload: new ArrayBuffer(10) }`. Verify that `_malloc`, `_obr_load_sofa`, and `_free` are called in the exact correct sequence with the correct pointer and size arguments. Do not proceed to Phase 9 until all tests in this checkpoint output a PASS.

### Phase 9: React UI Integration & Default HRTF Loading
* **Objective:** Expose the HRTF swapping capability to the frontend and ensure a default SOFA file is loaded on startup.
* **Instructions:**
    1. In `src/audio/AudioEngine.ts`, update `setupGraph` to call `await this.obrDecoder.loadSofa('/hrtf/MIT_KEMAR_Normal.sofa');` immediately after initializing the OBR decoder.
    2. Create `src/components/HrtfSelector.tsx`.
    3. Implement a `<select>` dropdown with two options mapped to the files in your directory: `MIT_KEMAR_Normal.sofa` and `Neumann_KU100_48k.sofa`.
    4. Pass an `onSelect` callback to the component that triggers `audioEngine.obrDecoder.loadSofa()` with the selected path.
    5. Render `HrtfSelector` inside `App.tsx` below the `FileLoader`.
* **TDD Checkpoint:** AGENT INSTRUCTION: Write a React Testing Library test for `HrtfSelector.tsx` ensuring the dropdown renders the correct options and fires the callback with the correct URL when changed. Verify `AudioEngine.ts` tests handle the new default SOFA loading. Do not proceed to Final Review until all tests output a PASS.

## 4. Final Review
1. Check browser DevTools network tab to ensure `.sofa` files are fetched with a 200 OK status.
2. Verify that rapidly switching between HRTFs in the UI does not cause memory growth in the WASM heap (proving `_free` is functioning correctly).
3. Ensure the project remains Lint-Pass.